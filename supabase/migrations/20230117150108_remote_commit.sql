create extension if not exists "pg_net" with schema "extensions";


create sequence "public"."countries_id_seq";

create table "public"."countries" (
    "id" integer not null default nextval('countries_id_seq'::regclass),
    "name" character varying(255) not null
);


create table "public"."order" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."order" enable row level security;

create table "public"."reservation" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."reservation" enable row level security;

create table "public"."restaurant" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "name" character varying not null,
    "about" text
);


alter table "public"."restaurant" enable row level security;

alter sequence "public"."countries_id_seq" owned by "public"."countries"."id";

CREATE UNIQUE INDEX countries_pkey ON public.countries USING btree (id);

CREATE UNIQUE INDEX order_pkey ON public."order" USING btree (id);

CREATE UNIQUE INDEX reservation_pkey ON public.reservation USING btree (id);

CREATE UNIQUE INDEX restaurant_name_key ON public.restaurant USING btree (name);

CREATE UNIQUE INDEX restaurant_pkey ON public.restaurant USING btree (id);

alter table "public"."countries" add constraint "countries_pkey" PRIMARY KEY using index "countries_pkey";

alter table "public"."order" add constraint "order_pkey" PRIMARY KEY using index "order_pkey";

alter table "public"."reservation" add constraint "reservation_pkey" PRIMARY KEY using index "reservation_pkey";

alter table "public"."restaurant" add constraint "restaurant_pkey" PRIMARY KEY using index "restaurant_pkey";

alter table "public"."restaurant" add constraint "restaurant_name_key" UNIQUE using index "restaurant_name_key";


set check_function_bodies = off;

CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
_filename text;
BEGIN
    select string_to_array(name, '/') into _parts;
    select _parts[array_length(_parts,1)] into _filename;
    -- @todo return the last part instead of 2
    return split_part(_filename, '.', 2);
END
$function$
;

CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
    select string_to_array(name, '/') into _parts;
    return _parts[array_length(_parts,1)];
END
$function$
;

CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
    select string_to_array(name, '/') into _parts;
    return _parts[1:array_length(_parts,1)-1];
END
$function$
;


